;; Analyzed by ClojureScript 1.7.170
{:use-macros {let-realised redlobster.macros, defer-node redlobster.macros, when-realised redlobster.macros, waitp redlobster.macros, promise redlobster.macros}, :excludes #{}, :name anchor.util, :imports nil, :requires {walk clojure.walk, clojure.walk clojure.walk, stream redlobster.stream, redlobster.stream redlobster.stream, promise redlobster.promise, redlobster.promise redlobster.promise, redlobster.io redlobster.io, cljs.reader cljs.reader, cljs.nodejs cljs.nodejs}, :uses {slurp redlobster.io, spit redlobster.io, read-string cljs.reader}, :defs {redirect {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 169, :column 7, :end-line 169, :end-column 15, :arglists (quote ([host m]))}, :name anchor.util/redirect, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 15, :method-params ([host m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 169, :end-line 169, :max-fixed-arity 2, :fn-var true, :arglists (quote ([host m]))}, dissoc-in {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 146, :column 7, :end-line 146, :end-column 16, :arglists (quote ([m v]))}, :name anchor.util/dissoc-in, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 16, :method-params ([m v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 146, :end-line 146, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m v]))}, timestamp {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 91, :column 10, :end-line 91, :end-column 19, :arglists (quote ([]))}, :name anchor.util/timestamp, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 19, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :line 91, :end-line 91, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, memoize-promise {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 25, :column 10, :end-line 25, :end-column 25, :arglists (quote ([f]))}, :name anchor.util/memoize-promise, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 25, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :line 25, :end-line 25, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f]))}, decompose-map {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 124, :column 7, :end-line 124, :end-column 20, :arglists (quote ([m] [stack m])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([m] [stack m]), :arglists ([m] [stack m]), :arglists-meta (nil nil)}}, :name anchor.util/decompose-map, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([m] [stack m]), :arglists ([m] [stack m]), :arglists-meta (nil nil)}, :method-params ([m] [stack m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 124, :end-line 124, :max-fixed-arity 2, :fn-var true, :arglists ([m] [stack m])}, datestamp {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 111, :column 10, :end-line 111, :end-column 19, :arglists (quote ([]))}, :name anchor.util/datestamp, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 19, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 4, :line 111, :end-line 111, :max-fixed-arity 0, :fn-var true, :arglists (quote ([]))}, clean {:name anchor.util/clean, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 149, :column 1, :end-line 149, :end-column 11, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 149, :column 6, :end-line 149, :end-column 11}}, safe-name {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 163, :column 7, :end-line 163, :end-column 16, :arglists (quote ([x]))}, :name anchor.util/safe-name, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 16, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 163, :end-line 163, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, response {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 174, :column 7, :end-line 174, :end-column 15, :arglists (quote ([x]))}, :name anchor.util/response, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 15, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 174, :end-line 174, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, format {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 66, :column 10, :end-line 66, :end-column 16, :arglists (quote ([s & subs])), :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(s subs)], :arglists ([s & subs]), :arglists-meta (nil)}}, :name anchor.util/format, :variadic true, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 16, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(s subs)], :arglists ([s & subs]), :arglists-meta (nil)}, :method-params [(s subs)], :protocol-impl nil, :arglists-meta (nil), :column 4, :line 66, :end-line 66, :max-fixed-arity 1, :fn-var true, :arglists ([s & subs])}, map-by {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 132, :column 7, :end-line 132, :end-column 13, :arglists (quote ([f s]))}, :name anchor.util/map-by, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 13, :method-params ([f s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 132, :end-line 132, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f s]))}, value-map {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 185, :column 7, :end-line 185, :end-column 16, :arglists (quote ([f m]))}, :name anchor.util/value-map, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 16, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 185, :end-line 185, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m]))}, str-contains? {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 59, :column 7, :end-line 59, :end-column 20, :arglists (quote ([a b]))}, :name anchor.util/str-contains?, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 20, :method-params ([a b]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 59, :end-line 59, :max-fixed-arity 2, :fn-var true, :arglists (quote ([a b]))}, linux? {:name anchor.util/linux?, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 16, :column 1, :end-line 16, :end-column 12, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 16, :column 6, :end-line 16, :end-column 12}}, pr-response {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 154, :column 7, :end-line 154, :end-column 18, :arglists (quote ([x]))}, :name anchor.util/pr-response, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 18, :method-params ([x]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 154, :end-line 154, :max-fixed-arity 1, :fn-var true, :arglists (quote ([x]))}, months {:name anchor.util/months, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 76, :column 1, :end-line 76, :end-column 12, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 76, :column 6, :end-line 76, :end-column 12}}, recompose-map {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 117, :column 7, :end-line 117, :end-column 20, :arglists (quote ([vs] [m vs])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([vs] [m vs]), :arglists ([vs] [m vs]), :arglists-meta (nil nil)}}, :name anchor.util/recompose-map, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 20, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([vs] [m vs]), :arglists ([vs] [m vs]), :arglists-meta (nil nil)}, :method-params ([vs] [m vs]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 117, :end-line 117, :max-fixed-arity 2, :fn-var true, :arglists ([vs] [m vs])}, ok-response {:name anchor.util/ok-response, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 150, :column 1, :end-line 150, :end-column 17, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 150, :column 6, :end-line 150, :end-column 17}}, cumul {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 18, :column 7, :end-line 18, :end-column 12, :arglists (quote ([s]))}, :name anchor.util/cumul, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 12, :method-params ([s]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 18, :end-line 18, :max-fixed-arity 1, :fn-var true, :arglists (quote ([s]))}, url {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 166, :column 7, :end-line 166, :end-column 10, :arglists (quote ([host m]))}, :name anchor.util/url, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 10, :method-params ([host m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 166, :end-line 166, :max-fixed-arity 2, :fn-var true, :arglists (quote ([host m]))}, dissoc-in-all {:protocol-inline nil, :meta {:file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :line 135, :column 7, :end-line 135, :end-column 20, :arglists (quote ([m v]))}, :name anchor.util/dissoc-in-all, :variadic false, :file "/Users/matthew/clojure/anchor/src/anchor/util.cljc", :end-column 20, :method-params ([m v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 135, :end-line 135, :max-fixed-arity 2, :fn-var true, :arglists (quote ([m v]))}}, :require-macros {redlobster.macros redlobster.macros, util anchor.util, anchor.util anchor.util}, :cljs.analyzer/constants {:seen #{:headers :status :body}, :order [:body :status :headers]}, :doc nil}